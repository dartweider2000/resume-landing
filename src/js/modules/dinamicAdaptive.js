import { widthIsGrowPattern } from './functions.js'
export { adaptive };
/*
Динамический адаптив.
Каждому элементу, который должен динамически адаптироваться, задаётся аттрибут data-dinamic-adaptive. Аттрибут принимает в себя 4 параметра.
1-ый (max/min) это тип медиа запроса. Будет min-width или max-width. 2-ой это ширина, на которой будет срабатывать медиа запрос
3-ий это className элемента, относительно которого будет происходить. 4-ый аргумент отвечает за, то каким способом будет позиционироваться элемент,
относительно того элемента, который был указан в 3-м аргументе. Доступны 4 варианта: prepend, append, after, before. Работают аналогично своим JS аналогам 
*/
const adaptive = () => {
   //Если элементов с динамическим адаптивом нет, то выходим
   if(!document.querySelectorAll('[data-dinamic-adaptive]').length)
      return;
   //Получаю массив всех элементов, которым присвоен аттрибут data-dinamic-adaptive.
   const dinamicElems = Array.from(document.querySelectorAll('[data-dinamic-adaptive]'));
   //Создаю словарь Map, который действует по принципу ключ-значение. Ключом у меня будет сочетание типа медиа запроса и ширины, на которой этот медиа запрос 
   //будет действовать. Например: 'max, 767'.
   const elemsData = new Map();

   //Перебираю каждый динамический элемент в цикле.
   dinamicElems.forEach(elem => {
      //Получаю значения, указанные в аттрибуте data-dinamic-adaptive. Загоняю эти данные в массив
      const dataset = elem.dataset.dinamicAdaptive.split(',').map(el => el.trim());
      //Это безусловно не медиа запрос. Чистых медиа запросов тут не будет, так как реализовать динамический адаптив с помощью matchMedia, для меня
      //не представляется возможным. Поэтому это просто название переменной, которое будет служить как ключ для словаря elemsData, который был описан выше
      const mediaQuery = `${dataset[0]},${dataset[1]}`;
      //Объект содержит в себе данные важные для совершение динамического адаптива. type - это тип медиа запроса min/max. width - это ширина, на которой начнёт
      //действовать медиа запрос. elem - сам динамический элемент, который нужно будет спозиционировать. relativeElement - элемент, относительно которого будет
      //спозиционирован элемент. position - это способ, которым динамический элемент будет спозиционирован prepend/append/after/before
      const data = {
         'type': dataset[0],
         'width': dataset[1],
         elem,
         'relativeElement': document.querySelector(`.${dataset[2]}`),
         'position': dataset[3]
      }
      //Добавление объекта data к словарю elemsData, так как элементов, которые могут иметь одинаковые медиа запросы, то есть одинаковый тип и ширину,
      //может быть много, то одному ключу(медиа запросу), будет соответствовать массив динаических элементов, которые имеют одинаковые значения типа и ширины
      //медиа запроса. Если данный ключ добавляется в словарь впервые, то добавление элемента происходит в массиве, если же данный ключ уже есть в массиве, то
      //оюъект просто добавляется к уже существующему массиву
      if(elemsData.get(mediaQuery) instanceof Array){
         //Добавляю объект data с ключом mediaQuery в уже существующий массив
         elemsData.get(mediaQuery).push(data);
      }else{
         //Добавляю объект data с ключом mediaQuery, при этом создаю массив.
         elemsData.set(mediaQuery, [data]);
      }
   });

   //Функция, которая выполняет пузырьковую сортировку, а в конце возвращает перевёрнутый массив. у меня есть словать elemsData, в котором у меня уже есть,
   //все элементы. Но в словаре элементы храняться не по порядку, а мне нужно было расположить группы элементов в строго заданной последовательности, от группы,
   //в которой самый широкий медиа запрос, то есть параметр width самый большой,до группы где самый узкий медиа запрос. Что же касается типа меди запроса, то в
   //ситуациях где параметы width равны, я отдавал приоритем тем медиа запросам, в которых type min, так как, по моему мнению они должны обрабатываться первыми
   //при уменьшении экрана и последними при увеличении. По крайней мене мне это показалось правильным(ну всё же работает так что "и так сойдёт") Так что это
   //функция будет сортировать мне массив ключей от словаря elemsData, чтобы потом я расположил группы медиа запросов в нужном мне порядке  
   const sort = (array) => {
      //Максимальный индекс массива - 1, который будет учавствовать в сравнение. -1, потомучто мы сравниваем a[i] с a[i + 1]. Поэтому в сравнении всегда будет
      //учавствовать индекс на один больше.Потом это значение будет уменьшаться на 1 с каждой итерацие главного цикла, так как в конце каждой итерации, на месте
      //maxIndextoCompare + 1, будет оказываться самый большой по значению элемент массива
      let maxIndextoCompare = array.length - 1;
      //Главный цикл, в котором мы будем перебирать все элементы, кроме первого, под нулевым индексом, который и так по завершении предыдущих
      //итераций окажется самым маленьким
      for(let i = 0; i < array.length - 1; i++){
         //Цикл, который ограничивает кол-во элементов, учавствующих в сравнении, причину описал выше
         for(let k = 0; k < maxIndextoCompare; k++){
            //Сравнение ведётся по типу медиа запроса и ширине медиа запроса
            const [type_0, width_0] = array[k].split(',');
            const [type_1, width_1] = array[k + 1].split(',');
            //Меняю местами элементы если ширина одного меньше ширины другого или когда ширины равны, но у того, который ниже в массиве ключей от словаря elemsData
            //тип медиа запроса min. Я уже писал выше, что отдаю предпочтение min.
            if(width_0 > width_1 || width_0 == width_1 && type_0 == 'min' && type_1 == 'max'){
               //Происходит простое приравнивание.
               let val = array[k];
               array[k] = array[k + 1];
               array[k + 1] = val;
            }
         }
         //Уменьшаю кол-во элементов, которые будут учавствать в следующем сравнении.
         maxIndextoCompare--;
      }
      //Возвращию перевёрнутый массив, чтобы в начале массива у меня оказались, самые широкие медиа запросы
      return array.reverse();
   }

   //Создаю, структурированный массив, состоящий из групп элементов с аналогичными медиа запросами, причём эти медиа запросы отсортированы от большего к меньшему.
   const sortElemsData =  sort([...elemsData.keys()]).reduce((result, key) => {
      //Добавляю в массив группы элементов, в соответствии с порядков, в отсортированном массиве ключей словаря eltmsData
      result.push(elemsData.get(key));
      return result;
   }, []);

   //Создаю массив функций, которые будут отвечать за транспортировку динамических элементом туда и обратно. Для каждой группы медиа запросов будет одна такая
   //функция. Потом в обработчике события resize у объекта window, этот массив будет вызываться и поочерёдно вызываться для каждой группы медиа запросов.
   const listeners =  sortElemsData.reduce((result, arrayBlock) => {
      //Массив, в котором будет храниться информация о домашнем адресе динамических элементов, чтобы они потом смогли вернуться назад на свои места. массив будет
      //хранить объекты backData, который содержит 4 поля. elem - сам динамический элемент, parentElement - родитель динамического элементо, ещё до перремещения
      //indexInParent - интекс, который динамический элемент занимает в массиве chidlren прямо перед его перемещением, beforeElement - элемент, который может
      //быть равен null если динамический элемент находится под индексом нуль в масиве chidlren, но задуман для элемента, котору находится под индерсом на один 
      //меньше чем у нашего динаического элемента.
      const transferBackData = [];
      //Получаю тип и ширину медиа запроса.
      const {type, width} = arrayBlock[0];

      //Функция, отвечает за доставку динамического элемента в его новый обитель. Делает, она это одновременного для всех элементов, имеющи одинаковые медиа запросы.
      const transfer = () => {
         //Перебираю каждый элемент из группы с одинаковыми медиа запросами
         arrayBlock.forEach(({elem, relativeElement, position}) => {
            //Получаю радительский элемент её до перемещения
            const parentElement = elem.parentElement;
            //Поулчаю массив дочерних элементов, родительского элемента
            const children = Array.from(parentElement.children);
            //Нахожу индекс динамического элемента в массиве
            const indexInParent = children.indexOf(elem);
            //Создаю переменную, для элемента находящегося перед рассматриваемым динамическим элемментом
            let   beforeElement = null;
            //Если элемент не первый с массиве chidldren, значит у него есть предшествующий элемент
            if(indexInParent){
               //Присваеваю предшествующий элемент
               beforeElement = children[indexInParent - 1];
            }
            //Создаю объект с данными, нужными для успешного возвращения элемента в родительский блок, Подробнее объект был расписан выше.
            const backData = {
               elem,
               parentElement,
               indexInParent,
               beforeElement
            }
            //Добавляю созданный объект backData в массив таких объектов
            transferBackData.unshift(backData);
            //Произвожу перемещение динамического элемента в его новый обитель
            relativeElement[position](elem);
         });
      }

      //Функция производит возвращение динамического элемента в родительский элемент
      const transferBack = () => {
         //Перебираю массив объектов backData
         transferBackData.forEach(({elem, parentElement, indexInParent, beforeElement}) => {
            //Если элемент был первым по индексу в родительском массиве перед отправкой в новый обитель, то он также добавляется первым в родительский блок, иначе
            //Добавляется позади того элемента перед которым был до предислокации.
            if(!indexInParent){
               //Перемещение самым первым элементом
               parentElement.prepend(elem);
            }else{
               //Перемещение позади элемента, преред которым был до переезда 
               beforeElement.after(elem);
            }
         });
      }

      //Переменная, своеобразный флаг, который указывает на то, что элемент уже перенесён и его нельзя переносить снова. С помощью замыкания данная переменная 
      //навсегда связана с данной функцией listener
      let transfered = false;
      //Функция, которая решает соответствует ли дання ширина экрана условиям, заданным в медиа запросе или нет.
      const listener = e => {
         //Если соответствует условиям дли max-width или для min-width и при этом данный элемент ещё не был перенёсён в новый обитель, то преносим, иначе если 
         //условия не соответствую ни одному типу медиа запроса и при этом элемент уже был перенесён, то возвращаем назад в родительский блок 
         if((type == 'max' && width >= window.innerWidth || type == 'min' && width <= window.innerWidth) && !transfered){       
            //Переносим
            transfer();
            //Устанавливаем флаг, что перенесли
            transfered = true;
         }else if((type == 'max' && width < window.innerWidth || type == 'min' && width > window.innerWidth) && transfered){    
            //Возвращаем в родительский блок
            transferBack();
            //Устанавливаем флг, что возвратили
            transfered = false;
         }
      }
      //Добавляем данныю функцию в общий массив таких функций.
      result.push(listener);
      return result;
   }, []);

   //Функция, которая содержит в себе замкнутую со своими переменными функцию perform
   const widthIsGrow = widthIsGrowPattern();

   //Создаю обработчик события resize для объекта window
   const resizeHandler = e => {
      //Если уменьшаем ширину экрана, то перебираем в том порядке, в котором уже имеется в массиве listeners, если же увеличиваем, то перебираем массив 
      //в обратном порядке. Это обязательное условие без которого ничего работать не будет!
      if(!widthIsGrow()){
         //Перебор в прямом порядке
         listeners.forEach(listener => listener());
      }else{
         //Перебор в обратном порядке
         for(let i = listeners.length - 1; i >= 0; i--){ 
            listeners[i]();
         }
      }
   };

   //Вызываю обработчик сразу.
   resizeHandler();
   //Добавляю обработчик события объекту window. Делаю это без throttle, так как нужно проверять ширину экрана так часто, насколько это возможно
   window.addEventListener('resize', resizeHandler);
}